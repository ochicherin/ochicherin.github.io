<HTML>
  <HEAD>
  <TITLE id=title>Чичерин Олег</TITLE>
  <META http-equiv=Content-Type content="text/html; charset=utf-8">
  <script src="/script.js"></script>
  <LINK href="/index_files/style.css" type=text/css rel=stylesheet>
</HEAD>
<BODY onLoad="initBody();">
  <H1>Нормальные формы</H1>

<pre>


<h2>Первая нормальная форма(1NF)</h2>

<h3>Определение</h3>
Таблица находится в первой нормальной форме, если каждый её атрибут атомарен, 
то есть может содержать только одно значение. Таким образом, не существует 1NF 
таблицы, в полях которых могут храниться списки значений. Для приведения 
таблицы к 1NF обычно требуется разбить таблицу на несколько отдельных таблиц.
Замечание: в реляционной модели отношение всегда находится 
в 1 (или более высокой) нормальной форме в том смысле, что 
иные отношения не рассматриваются в реляционной модели. 
То есть само определение понятия отношение заведомо подразумевает 
наличие 1NF.

<h3>Пример</h3>
<b>Пример приведения таблицы к первой нормальной форме</b>

Исходная, ненормализованная, таблица:

<table>
<tr><th>Сотрудник</th><th>Номер телефона</th></tr>
<tr><td>Иванов И. И.</td><td>283-56-82<br/>390-57-34</td></tr>
<tr><td>Петров П. Ю.</td><td>708-62-34</td></tr>
</table>


Таблица, приведённая к 1NF:


<table>
<tr><th>Сотрудник</th><th>Номер телефона</th></tr>
<tr><td>Иванов И. И.</td><td>283-56-82</td></tr>
<tr><td>Иванов И. И.</td><td>390-57-34</td></tr>
<tr><td>Петров П. Ю.</td><td>708-62-34</td></tr>
</table>

<h3>Атомарность атрибутов</h3>
 Вопрос об атомарности атрибутов решается на основе семантики данных,
то есть их смыслового значения. Атрибут атомарен, если его значение 
теряет смысл при любом разбиении на части или переупорядочивании. 
И наоборот, если какой-либо способ разбиения на части не лишает атрибут смысла, 
то атрибут не атомарен. Одно и то же значение может быть атомарным или 
неатомарным в зависимости от смысла этого значения. 
Например, значение "4286" является:
 - атомарным, если его смысл - "пин-код кредитной карты" 
   (при разбиении на части или переупорядочивании смысл теряется)
 - не атомарным, если его смысл - "четные цифры" 
   (при разбиении на части или переупорядочивании смысл не теряется)
Хорошим способом принятия решения о необходимости разбиения атрибута на части 
является вопрос: "будут ли части атрибута использоваться по отдельности?". 
Если да, то атрибут следует разделить (но так, чтобы сохранились осмысленные 
части атрибута). Далее необходимо снова задаться тем же вопросом для новой 
структуры и так до тех пор, пока не останется атрибутов, допускающих разбиение.
Примеры неатомарного атрибута, часто встречающиеся на практике: 
составные поля в виде строки идентификаторов, разделённых, скажем, запятыми: 
100,32,168,1045.

<h2>Вторая нормальная форма(2NF)</h2>

<h3>Определение</h3>
Таблица находится во второй нормальной форме, если она находится в первой 
нормальной форме, и при этом любой её атрибут, не входящий в состав возможного 
ключа, функционально полно зависит от каждого возможного ключа. Функционально 
полная зависимость означает, что атрибут функционально зависит от всего 
составного ключа, но при этом не находится в функциональной зависимости от 
какой-либо из входящих в него атрибутов (частей). 
Или другими словами: в 2NF нет неключевых атрибутов, зависящих от части 
составного ключа (плюс выполняются условия 1NF).


<h3>Пример</h3>
Пример приведения таблицы ко второй нормальной форме
Пусть Сотрудник и Должность вместе образуют первичный ключв такой таблице:

<table>
<tr><th>Сотрудник</th><th>Должность</th><th>Зарплата</th><th>Наличие компьютера</th></tr>
<tr><td>Гришин</td><td>Кладовщик</td><td>20000</td><td>Нет</td></tr>
<tr><td>Васильев</td><td>Программист</td><td>40000</td><td>Есть</td></tr>
<tr><td>Васильев</td><td>Кладовщик</td><td>25000</td><td>Нет</td></tr>
</table>

Зарплату сотруднику каждый начальник устанавливает сам, но её границы зависят от должности. 
Наличие же компьютера у сотрудника зависит только от должности, то есть 
зависимость от первичного ключа неполная.

В результате приведения к 2NF получаются две таблицы:

<table>
<tr><th>Сотрудник</th><th>Должность</th><th>Зарплата</th></tr>
<tr><td>Гришин</td><td>Кладовщик</td><td>20000</td></tr>
<tr><td>Васильев</td><td>Программист</td><td>40000</td></tr>
<tr><td>Васильев</td><td>Кладовщик</td><td>25000</td></tr>
</table>

Здесь первичный ключ, как и в исходной таблице, составной, но единственный 
не входящий в него атрибут Зарплата зависит теперь от всего ключа, то есть полно.

<table>
<tr><th>Должность</th><th>Наличие компьютера</th></tr>
<tr><td>Кладовщик</td><td>Нет</td></tr>
<tr><td>Программист</td><td>Есть</td></tr>
</table>

<h2>Третья нормальная форма(3NF)</h2>

Третья нормальная форма является достаточной при решении большинства 
практических задач, и процесс проектирования реляционной базы данных, 
как правило, заканчивается приведением к ней. 3NF была изначально 
сформулирована Э. Ф. Коддом в 1971 году.

<h3>Определение</h3>
Согласно определению Кодда, таблица находится в 3NF тогда и только тогда, 
когда выполняются следующие условия:
 - Отношение R (таблица) находится во второй нормальной форме; 
 - Каждый непервичный атрибут R находится в нетранзитивной (то есть прямой) 
   зависимости от каждого ключа R. 
Непервичный (неключевой) атрибут R - это атрибут, который не принадлежит ни 
одному из возможных (альтернативных) ключей R. 
Транзитивная зависимость - это функциональная зависимость, при которой 
X  Z (X определяет Z) не напрямую, а посредством отношения X  Y и Y  Z 
(отношение Y  X не является обязательным условием).

Определение 3NF, эквивалентное определению Кодда, но по-другому сформулированное, 
дал Карло Заниоло в 1972 году. Согласно ему, таблица находится в 3НФ тогда и только 
тогда, когда для каждой из ее функциональных зависимостей X  A выполняется хотя бы одно 
из следующих условий:
 - Х содержит А (то есть X  A - тривиальная функциональная зависимость) 
 - Х - суперключ 
 - А - первичный атрибут (то есть А входит в состав альтернативного ключа). 
Определение Заниоло четко определяет разницу между 3NF и более строгой 
нормальной формой Бойса-Кодда (НФБК): НФБК исключает третье условие 
("А - первичный атрибут").

<h3>Пример</h3>
<b>Пример приведения таблицы к третьей нормальной форме</b>
Исходная таблица:
<table>
<tr><th>Фамилия</th><th>Отдел</th><th>Телефон</th></tr>
<tr><td>Гришин</td><td>1</td><td>11-22-33</td></tr>
<tr><td>Васильев</td><td>1</td><td>11-22-33</td></tr>
<tr><td>Петров</td><td>2</td><td>44-55-66</td></tr>
</table>


В результате приведения к 3НФ получаются две таблицы:

<table>
<tr><th>Фамилия</th><th>Отдел</th></tr>
<tr><td>Гришин</td><td>1</td></tr>
<tr><td>Васильев</td><td>1</td></tr>
<tr><td>Петров</td><td>2</td></tr>
</table>

<table>
<tr><th>Отдел</th><th>Телефон</th></tr>
<tr><td>1</td><td>11-22-33</td></tr>
<tr><td>2</td><td>44-55-66</td>
</tr>
</table>

<h3>Ничего, кроме ключа</h3>

Запоминающееся и, по традиции, наглядное резюме определения 3NF Кодда было дано 
Биллом Кентом: каждый неключевой атрибут "должен предоставлять информацию о ключе,
полном ключе и ни о чем, кроме ключа".
Условие зависимости от "полного ключа" неключевых атрибутов обеспечивает то, что 
таблица находится во второй нормальной форме; а условие зависимости их от 
"ничего, кроме ключа" - то, что они находятся в третьей нормальной форме.
Крис Дэйт говорит о резюме Кента как о "интуитивно привлекательной характеристике" 
3NF, и замечает, что с небольшим изменением она может служить и как определение 
более строгой нормальной формы Бойса-Кодда: "Каждый атрибут должен предоставлять 
информацию о ключе, полном ключе и ни о чем, кроме ключа". Вариант определения 3NF 
Кента является менее строгим, чем вариант НФБК Дэйта, поскольку первая утверждает 
только, что неключевые атрибуты зависят от ключей. Первичные атрибуты 
(которые являются ключами или их частями) вовсе не должны быть функционально 
зависимыми; каждый из них предоставляет информацию о ключе предоставлением самого 
ключа или его части. Здесь следует отметить, что это правило справедливо только для 
неключевых атрибутов, так как применение его ко всем атрибутам будет полностью запрещать 
все сложные альтернативные ключи, поскольку каждый элемент такого ключа будет нарушать 
условие "полного ключа".

<h2>Нормальная форма Бойса - Кодда(BCNF)</h2>

Иногда нормальную форму Бойса-Кодда называют усиленной третьей нормальной 
формой, поскольку она во всех отношениях сильнее (строже) по сравнению с 
ранее определённой ЗНФ[1].
Названа в честь Рэя Бойса и Эдгара Кодда, хотя Кристофер Дейт указывает, 
что на самом деле строгое определение <третьей> нормальной формы, эквивалентное 
определению нормальной формы Бойса-Кодда, впервые было дано Иэном Хитом 
(англ. Ian Heath) в 1971 году, поэтому данную форму следовало бы называть 
"нормальной формой Хита".


<h3>Определение</h3>
Отношение находится в BCNF тогда и только тогда, когда каждая его нетривиальная 
и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта 
некоторый потенциальный ключ.
Менее формально, переменная отношения находится в нормальной форме Бойса-Кодда 
тогда и только тогда, когда детерминанты всех ее функциональных зависимостей 
являются потенциальными ключами.
Для определения BCNF следует понимать понятие функциональной зависимости атрибутов 
отношения.
Пусть R является переменной отношения, а X и Y - произвольными подмножествами 
множества атрибутов переменной отношения R. Y функционально зависимо от X тогда 
и только тогда, когда для любого допустимого значения переменной отношения R, 
если два кортежа переменной отношения R совпадают по значению X, они также совпадают 
и по значению Y. Подмножество X называют детерминантом, а Y - зависимой частью.
Функциональная зависимость тривиальна тогда и только тогда, когда ее правая 
(зависимая) часть является подмножеством ее левой части (детерминанта).
Ситуация, когда отношение будет находиться в 3NF, но не в BCNF, возникает, например, 
при условии, что отношение имеет два (или более) потенциальных ключа, которые 
являются составными и имеют общий атрибут. На практике такая ситуация встречается 
достаточно редко, для всех прочих отношений 3NF и BCNF эквивалентны.

<h3>Первый пример</h3>

Исходная таблица:

<table>
<tr><th>Номер клиента</th><th>Дата собеседования</th><th>Время собеседования</th><th>Номер комнаты</th><th>Номер сотрудника</th></tr>
<tr><td>С345</td><td>13.10.03</td><td>13.00</td><td>103</td><td>А138</td></tr>
<tr><td>С355</td><td>13.10.03</td><td>13.05</td><td>103</td><td>А136</td></tr>
<tr><td>С368</td><td>13.09.03</td><td>13.00</td><td>102</td><td>А154</td></tr>
<tr><td>С366</td><td>13.09.03</td><td>13.30</td><td>105</td><td>А207</td></tr>
</table>

В результате приведения к форме Бойса-Кодда получаются две таблицы:

<table>
<tr><th>Номер клиента</th><th>Дата собеседования</th><th>Время собеседования</th><th>Номер Сотрудника</th></tr>
<tr><td>С345</td><td>13.10.03</td><td>13.00</td><td>А138</td></tr>
<tr><td>С355</td><td>13.10.03</td><td>13.05</td><td>А136</td></tr>
<tr><td>С368</td><td>13.09.03</td><td>13.00</td><td>А154</td></tr>
<tr><td>С366</td><td>13.09.03</td><td>13.30</td><td>А207</td></tr>
</table>

<table>
<tr><th>Дата собеседования</th><th>Номер сотрудника</th><th>Номер комнаты</th></tr>
<tr><td>13.10.03</td><td>А138</td><td>103</td></tr>
<tr><td>13.10.03</td><td>А136</td><td>103</td></tr>
<tr><td>13.09.03</td><td>А154</td><td>102</td></tr>
<tr><td>13.09.03</td><td>А207</td><td>105</td></tr>
</table>

<h3>Второй пример</h3>

Предположим, создаётся таблица бронирования для теннисных кортов на день: 
<table>
<tr><th>Номер корта</th><th>Время начала</th><th>Время окончания</th><th>Тариф</th><th>Член клуба</th></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td><td></td></tr>
</table>

Тариф зависит от выбранного корта и членства в клубе.
Таким образом, возможны следующие составные первичные ключи: 
 - <b>{Номер корта, Время начала}</b>, 
 - <b>{Номер корта, Время окончания}</b>, 
 - <b>{Тариф, Время начала}</b>, 
 - <b>{Тариф, Время окончания}</b>.
Таблица соответствует второй и третьей нормальной форме, так как атрибуты, 
не входящие в состав первичного ключа, зависят от составного первичного ключа 
целиком (2NF) и нет транзитивных зависимостей (3NF).
Тем не менее, существует функциональная зависимость тарифа от номера корта. 
То есть, по ошибке можно нарушить логическую целостность и, например, приписать 
тариф <i>Premium</i> для первого корта, хотя тариф <i>Premium</i> может относиться 
только ко второму корту.</p>
Можно улучшить структуру, разбив таблицу на две: 

<table>
<tr><th>Номер корта</th><th>Время начала</th><th>Время окончания</th><th>Член клуба</th></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
</table>

<table>
<tr><th>Номер корта</th><th>Тариф</th><th>Член клуба</th></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td></td><td></td><td></td></tr>
</table>

Данное отношение будет соответствовать BCNF.


<h2>Четвертая нормальная форма (4NF)</h2>

<h3>Определение</h3>

Отношение находится в 4NF, если оно находится в BCNF и не содержит нетривиальных 
многозначных зависимостей. То есть все многозначные зависимости являются, 
по сути, функциональными зависимостями от ключей отношения.

<h3>Пример</h3>

Предположим, что рестораны производят разные виды пиццы, а службы доставки ресторанов 
работают только в определенных районах города. Составной ключ таблицы такого 
отношения включает три поля: 
<b>{Ресторан, Вид пиццы, Район доставки}</b>.
Такая таблица не соответствует 4NF, так как существует многозначная зависимость:
 - <b>{Ресторан}  {Вид пиццы}</b>
 - <b>{Ресторан}  {Район доставки}</b>
То есть, например, при добавлении нового вида пиццы придется внести по одной 
новой записи для каждого района доставки. Возможна логическая аномалия, при 
которой определенному виду пиццы будут соответствовать лишь некоторые районы 
доставки из обслуживаемых рестораном районов.
Для предотвращения аномалии нужно разбить многозначную зависимость - разместить 
независимые факты в разных таблицах. В данном примере - <b>{Ресторан, Вид пиццы}</b> 
и <b>{Ресторан, Район доставки}</b>.

<h2>Пятая нормальная форма (5NF)</h2>

<h3>Определение</h3>

  Таблица находится в 5NF, если она находится в 4NF и любая многозначная зависимость 
соединения в ней является тривиальной. Пятая нормальная форма в большей степени 
является теоретическим исследованием и практически не применяется при реальном 
проектировании баз данных. Это связано со сложностью определения самого наличия 
зависимостей "проекции - соединения", поскольку утверждение о наличии такой зависимости 
должно быть сделано для всех возможных состояний БД.
  Очень редко таблица, находящаяся в 4NF, не соответствует 5NF. Это те ситуации, 
в которых реальные правила, ограничивающие допустимые комбинации атрибутов, никак 
не выражены в структуре таблицы (например, правила определенного бизнеса). В таком 
случае, если таблица не приведена к 5NF, бремя обеспечения логической целостности 
данных отчасти переляжет на приложение, отвечающее за добавление, удаление и изменения 
таблицы. В этом случае существует риск возникновения аномалий данных. Пятая нормальная 
форма исключает возникновение таких аномалий.

<h3>Пример</h3>

  Предположим, что продавец может торговать продукцией нескольких фирм, ассортимент 
у фирм различен, причем продавец может предлагать только часть товаров конкретной 
фирмы.
Отношение <b>{Продавец, Фирма, Вид товара}</b> соответствует 4NF, однако не отражает 
ограничения, связанного с ассортиментом продукции фирм. Может возникнуть кортеж, 
в котором фирме будет соответствовать вид товара, который она не выпускает.
В данном случае (для приведения к 5NF) отношение должно быть разбито на три: 
 - <b>{Продавец, Фирма}</b>, 
 - <b>{Фирма, Вид товара}</b>, 
 - <b>{Продавец, Вид товара}</b>.

<h2>Доменно-ключевая нормальная форма (DKNF)</h2>

Её предложил Рональд Фагин в 1981 году

<h3>Определение</h3>

Отношение в DKNF не имеет аномалий модификации. Другими словами, что бы ни менялось 
- ничего не потеряется, eсли соблюдены все ограничения относительно ключей и доменов. 
Формулировка слишком общая, но суть ее заключается в том, что если выполнять некоторые 
правила, то при любых действиях с таблицей ее целостность не пострадает и вся 
необходимая информация сохранится.

<h3>Пример</h3>

Если рассматривать на примере, то правила действуют примерно так: нельзя просто 
удалить категорию из таблицы категорий, если с этой категорией связаны, например, 
продукты из таблицы продуктов. Прежде чем удалять категорию, необходимо выполнить 
предварительные действия в таблице продуктов (например, поле отвечающее за id категории 
этого товара нужно сделать NULL).

<h2>Шестая нормальная форма (6NF)</h2>

Введена К. Дейтом в как обобщение пятой нормальной формы для темпоральной базы данных.

<h3>Определение</h3>

<h3>Пример</h3>


<h2>12 правил Кодда</h2>

правило 0: Основное правило (Foundation Rule): 
           Реляционная СУБД должна быть способна полностью управлять базой данных, 
           используя связи между данными.:
           Чтобы быть реляционной системой управления базами данных (СУБД), 
           система должна использовать исключительно свои реляционные возможности 
           для управления базой данных.
правило 1: Явное представление данных (The Information Rule):
           Информация должна быть представлена в виде данных, хранящихся в ячейках. 
           Данные, хранящиеся в ячейках, должны быть атомарны. Порядок строк в 
           реляционной таблице не должен влиять на смысл данных.
правило 2: Гарантированный доступ к данным (Guaranteed Access Rule):
           Доступ к данным должен быть свободен от двусмысленности. К каждому 
           элементу данных должен быть гарантирован доступ с помощью комбинации 
           имени таблицы, первичного ключа строки и имени столбца.
правило 3: Полная обработка неизвестных значений (Systematic Treatment of Null Values):
           Неизвестные значения NULL, отличные от любого известного значения, должны 
           поддерживаться для всех типов данных при выполнении любых операций. Например, 
           для числовых данных неизвестные значения не должны рассматриваться как нули, 
           а для символьных данных - как пустые строки.
правило 4: Доступ к словарю данных в терминах реляционной модели 
           (Active On-Line Catalog Based on the Relational Model):
           Словарь данных должен сохраняться в форме реляционных таблиц, 
           и СУБД должна поддерживать доступ к нему при помощи стандартных 
           языковых средств, тех же самых, которые используются для работы 
           с реляционными таблицами, содержащими пользовательские данные.
правило 5: Полнота подмножества языка (Comprehensive Data Sublanguage Rule):
           Система управления реляционными базами данных должна поддерживать 
           хотя бы один реляционный язык, который
             - имеет линейный синтаксис,
             - может использоваться как интерактивно, так и в прикладных программах,
             - поддерживает операции определения данных, определения представлений, 
               манипулирования данными (интерактивные и программные), ограничители 
               целостности, управления доступом и операции управления транзакциями 
               (begin, commit и rollback).
правило 6: Возможность модификации представлений (View Updating Rule):
           Каждое представление должно поддерживать все операции манипулирования 
           данными, которые поддерживают реляционные таблицы: операции выборки, 
           вставки, модификации и удаления данных.
правило 7: Наличие высокоуровневых операций управления данными 
           (High-Level Insert, Update, and Delete):
           Операции вставки, модификации и удаления данных должны поддерживаться 
           не только по отношению к одной строке реляционной таблицы, 
           но по отношению к любому множеству строк.
правило 8: Физическая независимость данных (Physical Data Independence):
           Приложения не должны зависеть от используемых способов хранения 
           данных на носителях, от аппаратного обеспечения компьютеров, 
           на которых находится реляционная база данных.
правило 9: Логическая независимость данных (Logical Data Independence):
           Представление данных в приложении не должно зависеть от структуры 
           реляционных таблиц. Если в процессе нормализации одна реляционная 
           таблица разделяется на две, представление должно обеспечить объединение 
           этих данных, чтобы изменение структуры реляционных таблиц не сказывалось 
           на работе приложений.
правило 10: Независимость контроля целостности (Integrity Independence):
            Вся информация, необходимая для поддержания целостности, должна 
            находиться в словаре данных. Язык для работы с данными должен 
            выполнять проверку входных данных и автоматически поддерживать 
            целостность данных.
правило 11: Дистрибутивная независимость (Distribution Independence):
            База данных может быть распределённой, может находиться на нескольких 
            компьютерах, и это не должно оказывать влияние на приложения. 
            Перенос базы данных на другой компьютер не должен оказывать влияния 
            на приложения.
правило 12: Согласование языковых уровней (The Nonsubversion Rule):
            Если используется низкоуровневый язык доступа к данным, он не 
            должен игнорировать правила безопасности и правила целостности, 
            которые поддерживаются языком более высокого уровня.



<h2>Кортеж</h2>

<h3>Определение</h3>
В математике кортеж - последовательность конечного числа элементов. Многие 
математические объекты формально определяются как кортежи. Например, граф 
определяется как кортеж (V,E), где V - это набор вершин, а E - подмножество V x V, 
обозначающее рёбра.

В базах данных, кортежем называется группа взаимосвязанных элементов данных;

В реляционных базах данных кортеж - это элемент отношения, строка таблицы; 
упорядоченный набор из N элементов.



<h2>Отношение (relation)</h2>

<h3>Определение</h3>

N-арным отношением R, или отношением R степени n, называют подмножество декартовa 
произведения множеств , не обязательно различных. Исходные множества D1,D2,...,Dn 
называют в модели доменами (в СУБД используется понятие тип данных).
  Отношение имеет простую графическую интерпретацию, оно может быть представлено 
в виде таблицы, столбцы (поля, атрибуты) которой соответствуют вхождениям доменов 
в отношение, а строки (записи) - наборам из n значений, взятых из исходных доменов. 
Число строк (кортежей) n, называют кардиальным числом отношения, или мощностью 
отношения.
Такая таблица обладает рядом свойств:
1. В таблице нет двух одинаковых строк.
2. Таблица имеет столбцы, соответствующие атрибутам отношения.
3. Каждый атрибут в отношении имеет уникальное имя.
4. Порядок строк в таблице произвольный.
Под атрибутом здесь понимается вхождение домена в отношение. 
Строки отношения называются кортежами.
Далее следует формализованное определение введённых понятий.
 - Заголовок Hr (или схема) отношения r - конечное множество упорядоченных пар 
   вида [A, T], где A называется именем атрибута, а T обозначает имя некоторого 
   базового типа или ранее определенного домена, то есть множества допустимых 
   значений. По определению требуется, чтобы все имена атрибутов в заголовке 
   отношения были различны.
 - Кортеж tr, соответствующий заголовку Hr - множество упорядоченных триплетов 
   вида [A, T, v], по одному такому триплету для каждого атрибута в Hr. Третий 
   элемент - v - триплета [A, T, v] должен являться допустимым значением типа 
   данных или домена T. 
   Замечание: так как имена атрибутов уникальны, то указание домена в кортеже излишне.
 - Тело Br отношения - неупорядоченное множество различных кортежей tr.
 - Значением Vr отношения r называется пара множеств Hr и Br.
Полезно также понятие первичного ключа - это такой набор атрибутов, который 
однозначно определяет кортеж и минимален среди всех своих подмножеств (то есть 
нельзя убрать ни один из атрибутов). При добавлении новых записей первичный ключ 
обязан оставаться первичным ключом (например, неверным будет использование в 
качестве первичного ключа набора Имя + Отчество + Фамилия сотрудника, даже если 
на момент создания таблицы полных тёзок среди заносимых в неё людей не было).

<h3>Пример</h3>
Допустим, содержание доменов следующее:
  D1 = {Иванов, Петров, Сидоров}
  D2 = {Физика, Химия}
  D3 = {3,4,5}
Тогда полное декартово произведение состоит из 18 троек, где первый элемент тройки - 
одна из фамилий, второй элемент - учебная дисциплина, а третий - оценка.
Тогда отношение R может моделировать реальную ситуацию и содержать пять строк, 
которые соответствуют результатам сессии (Петров экзамен по Физике не сдавал):
<table>
<tr><th colspan="3">R</th></tr>
<tr><th>Фамилия</th><th>Предмет</th><th>Оценка</th></tr>
<tr><td>Иванов</td><td>Физика</td><td>4</td></tr>
<tr><td>Иванов</td><td>Химия</td><td>3</td></tr>
<tr><td>Петров</td><td>Химия</td><td>5</td></tr>
<tr><td>Сидоров</td><td>Физика</td><td>5</td></tr>
<tr><td>Сидоров</td><td>Химия</td><td>4</td></tr>
</table>

<h3>Операции, определённые над отношениями</h3>

 - Объединение - тело нового отношения является объединением тел старых 
 - Пересечение - тело нового отношения является пересечением тел старых 
 - Вычитание - тело нового отношения получено вычитанием тел старых 
 - Проекция - частный случай пересечения 
 - Декартово произведение - тело нового отношения является декартовым 
   произведением тел старых 
 - Выборка - из исходного отношения выбираются лишь те кортежи, которые 
   удовлетворяют новым доменам (заданным в условиях выборки) 
 - Соединение - выборка над декартовым произведением 
 - Деление - делитель является унарным отношением (то есть с единственным 
   атрибутом). Частное - совпадающие части кортежей делимого, перед которыми 
   стоит делитель. 

В полученном объекте могут появиться одинаковые кортежи (например, при 
проецировании отношения из примера на отношение, заголовок которого состоит 
из единственного атрибута - фамилии, получим две пары одинаковых кортежей 
(два Иванова и два Сидорова) и ещё один кортеж (Петров). Необходимо удалить 
дубликаты, чтобы этот объект являлся отношением (тогда будет один Иванов, один 
Петров и один Сидоров).

Пример деления

<table>
<tr><th colspan="3">Делимое</th></tr>
<tr><th>Атрибут A</th><th>Атрибут B</th><th>Атрибут C</th></tr>
<tr><td>a</td><td>c</td><td>d</td></tr>
<tr><td>b</td><td>c</td><td>d</td></tr>
<tr><td>a</td><td>p</td><td>q</td></tr>
<tr><td>b</td><td>x</td><td>y</td></tr>
</table>

<table>
<tr><th colspan="1">Делитель</th></tr>
<tr><th>Атрибут A</th></tr>
<tr><td>a</td></tr>
<tr><td>b</td></tr>
</table>

<table>
<tr><th colspan="2">Частное</th></tr>
<tr><th>Атрибут B</th><th>Атрибут C</th></tr>
<tr><td>c</td><td>d</td></tr>
</table>




Всё.
</pre>


</BODY>
</HTML>
